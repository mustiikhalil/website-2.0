// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum MediaType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case images = 0
  case video = 1

  public static var max: MediaType { return .video }
  public static var min: MediaType { return .images }
}


public enum LinkType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case github = 0
  case appstore = 1

  public static var max: LinkType { return .appstore }
  public static var min: LinkType { return .github }
}


public struct Media: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_22_9_24() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsMedia(bb: ByteBuffer) -> Media { return Media(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case url = 4
    case type = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var url: String? { let o = _accessor.offset(VTOFFSET.url.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var urlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.url.v) }
  public var type: MediaType { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? .images : MediaType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .images }
  public static func startMedia(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(url: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: url, at: VTOFFSET.url.p) }
  public static func add(type: MediaType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: VTOFFSET.type.p) }
  public static func endMedia(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMedia(
    _ fbb: inout FlatBufferBuilder,
    urlOffset url: Offset = Offset(),
    type: MediaType = .images
  ) -> Offset {
    let __start = Media.startMedia(&fbb)
    Media.add(url: url, &fbb)
    Media.add(type: type, &fbb)
    return Media.endMedia(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.url.p, fieldName: "url", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: MediaType.self)
    _v.finish()
  }
}

public struct Link: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_22_9_24() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsLink(bb: ByteBuffer) -> Link { return Link(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case url = 4
    case type = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var url: String? { let o = _accessor.offset(VTOFFSET.url.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var urlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.url.v) }
  public var type: LinkType { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? .github : LinkType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .github }
  public static func startLink(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(url: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: url, at: VTOFFSET.url.p) }
  public static func add(type: LinkType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: VTOFFSET.type.p) }
  public static func endLink(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLink(
    _ fbb: inout FlatBufferBuilder,
    urlOffset url: Offset = Offset(),
    type: LinkType = .github
  ) -> Offset {
    let __start = Link.startLink(&fbb)
    Link.add(url: url, &fbb)
    Link.add(type: type, &fbb)
    return Link.endLink(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.url.p, fieldName: "url", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: LinkType.self)
    _v.finish()
  }
}

public struct Project: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_22_9_24() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsProject(bb: ByteBuffer) -> Project { return Project(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case name = 6
    case details = 8
    case techStack = 10
    case media = 12
    case links = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: Int32 { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var details: String? { let o = _accessor.offset(VTOFFSET.details.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var detailsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.details.v) }
  public var hasTechStack: Bool { let o = _accessor.offset(VTOFFSET.techStack.v); return o == 0 ? false : true }
  public var techStackCount: Int32 { let o = _accessor.offset(VTOFFSET.techStack.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func techStack(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.techStack.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var hasMedia: Bool { let o = _accessor.offset(VTOFFSET.media.v); return o == 0 ? false : true }
  public var mediaCount: Int32 { let o = _accessor.offset(VTOFFSET.media.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func media(at index: Int32) -> Media? { let o = _accessor.offset(VTOFFSET.media.v); return o == 0 ? nil : Media(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasLinks: Bool { let o = _accessor.offset(VTOFFSET.links.v); return o == 0 ? false : true }
  public var linksCount: Int32 { let o = _accessor.offset(VTOFFSET.links.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func links(at index: Int32) -> Link? { let o = _accessor.offset(VTOFFSET.links.v); return o == 0 ? nil : Link(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startProject(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(id: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: id, def: 0, at: VTOFFSET.id.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(details: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: details, at: VTOFFSET.details.p) }
  public static func addVectorOf(techStack: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: techStack, at: VTOFFSET.techStack.p) }
  public static func addVectorOf(media: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: media, at: VTOFFSET.media.p) }
  public static func addVectorOf(links: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: links, at: VTOFFSET.links.p) }
  public static func endProject(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createProject(
    _ fbb: inout FlatBufferBuilder,
    id: Int32 = 0,
    nameOffset name: Offset = Offset(),
    detailsOffset details: Offset = Offset(),
    techStackVectorOffset techStack: Offset = Offset(),
    mediaVectorOffset media: Offset = Offset(),
    linksVectorOffset links: Offset = Offset()
  ) -> Offset {
    let __start = Project.startProject(&fbb)
    Project.add(id: id, &fbb)
    Project.add(name: name, &fbb)
    Project.add(details: details, &fbb)
    Project.addVectorOf(techStack: techStack, &fbb)
    Project.addVectorOf(media: media, &fbb)
    Project.addVectorOf(links: links, &fbb)
    return Project.endProject(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.details.p, fieldName: "details", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.techStack.p, fieldName: "techStack", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.media.p, fieldName: "media", required: false, type: ForwardOffset<Vector<ForwardOffset<Media>, Media>>.self)
    try _v.visit(field: VTOFFSET.links.p, fieldName: "links", required: false, type: ForwardOffset<Vector<ForwardOffset<Link>, Link>>.self)
    _v.finish()
  }
}

public struct Projects: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_22_9_24() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsProjects(bb: ByteBuffer) -> Projects { return Projects(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case data = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasData: Bool { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? false : true }
  public var dataCount: Int32 { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func data(at index: Int32) -> Project? { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? nil : Project(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startProjects(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(data: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: data, at: VTOFFSET.data.p) }
  public static func endProjects(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createProjects(
    _ fbb: inout FlatBufferBuilder,
    dataVectorOffset data: Offset = Offset()
  ) -> Offset {
    let __start = Projects.startProjects(&fbb)
    Projects.addVectorOf(data: data, &fbb)
    return Projects.endProjects(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.data.p, fieldName: "data", required: false, type: ForwardOffset<Vector<ForwardOffset<Project>, Project>>.self)
    _v.finish()
  }
}

